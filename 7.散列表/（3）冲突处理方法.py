'''冲突处理'''

'''
（1）开放地址法：一旦冲突，利用某种规则，寻找另一个空地址（open addressing）
发生了第i次冲突，试探的下一个地址将增加di，基本公式：hi(key) = (h(key)+di) % table_size
其中，1<=i<=table_size
di决定了不同方案：线性探测（di = i），平方探测（di = +-i^2，若超出再取余），双散列（di = i*h2(key)）

一、线性探测法：举例[47,7,29,11,9,84,54,20,30]，设散列函数为 h(key) = key % 11，di=1，2，3....
规定散列表长为13
则有 关键词：  47  7  29  11  9  84  54  20  30
计算散列地址：  3   7  7   0   9  7   10  9   8
   冲突次数：  0   0  1   0   0  3   1   3   6
   
计算成功平均查找长度（ASLs）和不成功平均查找长度（ASLu），此时散列表最终形态如下：
h(key) 0  1  2  3  4  5  6  7  8  9  10 11 12
  key  11 30    47          7  29 9  84 54 20
冲突次  0  6     0           0  1  0  3  1  3

ASLs = (1+7+1+1+2+1+4+2+4)/9 = 23/9 = 2.56 （实际上就是把每个散列表中存在的元素，查找次数算一遍）
ASLu = (3+2+1+2+1+1+1+9+8+7+6)/11 = 41/11 = 3.73 （实际上就是以每个散列表位置为起始点，寻找从该处出发 到 第一次失败的查找次数）
     即：从起始点到第一次出现空白处的查找次数

但是这个方法，有聚集现象

二、平方探测法：也叫二次探测，增量序列为1^2,-1^2,2^2,-2^2,....,q^2,-q^2 且q<=table_size/2
举例[47,7,29,11,9,84,54,20,30]，设散列函数为 h(key) = key % 11
规定散列表长为11
则有 关键词：  47  7  29  11  9  84  54  20  30
计算散列地址：  3   7  7   0   9  7   10  9   8
   冲突次数：  0   0  1   0   0  2   0   3   3

计算成功平均查找长度（ASLs）和不成功平均查找长度（ASLu），此时散列表最终形态如下：
h(key) 0  1  2  3  4  5  6  7  8  9  10
  key  11 30 20 47       84 7  29 9  54
冲突次  0  4  4  0        -1 0  1  0  0

ASLs = (1+4+4+1+3+1+2+1+1)/9 = 18/9 = 2

但是这个方法，容易出现找不到空位，一直反复跳来跳去
定理——如果列表长度 table_size = 4k+3 的素数时，平方探测法即可探查整个列表空间

三、双散列探测法：di为i*h2(key)，h2(key)是另一个散列函数，探测序列成：h2(key)、2*h2(key)、3*h2(key)...
对于任意的key，h2(key) != 0
应该保证所有的散列存储单元，都能够被探测到，以下形式效果较好：h2(key)=p-(key mod p)
并且，p < table_size , p和table_size都是素数

四、再散列（rehashing）
当装填因子太大时，查找效率会下降，一般来讲装填因子0.5~0.85最好
散列表扩大时，原来的元素必须重新计算，再填入新的散列表

五、分离链接法：把冲突位置上的所有关键词，串成一个单链表，即：哈希表存头指针
'''

